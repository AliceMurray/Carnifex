// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scoreboard.proto

#ifndef PROTOBUF_scoreboard_2eproto__INCLUDED
#define PROTOBUF_scoreboard_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace wire {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_scoreboard_2eproto();
void protobuf_AssignDesc_scoreboard_2eproto();
void protobuf_ShutdownFile_scoreboard_2eproto();

class Message;
class Event;
class ContestSetup;
class Problem;
class Team;

enum SState {
  CORRECT = 1,
  WRONG = 2,
  PENDING = 3,
  FIRST = 4
};
bool SState_IsValid(int value);
const SState SState_MIN = CORRECT;
const SState SState_MAX = FIRST;
const int SState_ARRAYSIZE = SState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SState_descriptor();
inline const ::std::string& SState_Name(SState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SState_descriptor(), value);
}
inline bool SState_Parse(
    const ::std::string& name, SState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SState>(
    SState_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MessageTypeCase {
    kEvent = 1,
    kSetup = 2,
    kHeartBeat = 3,
    kUnfreeze = 4,
    MESSAGETYPE_NOT_SET = 0,
  };

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .wire.Event event = 1;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::wire::Event& event() const;
  inline ::wire::Event* mutable_event();
  inline ::wire::Event* release_event();
  inline void set_allocated_event(::wire::Event* event);

  // optional .wire.ContestSetup setup = 2;
  inline bool has_setup() const;
  inline void clear_setup();
  static const int kSetupFieldNumber = 2;
  inline const ::wire::ContestSetup& setup() const;
  inline ::wire::ContestSetup* mutable_setup();
  inline ::wire::ContestSetup* release_setup();
  inline void set_allocated_setup(::wire::ContestSetup* setup);

  // optional int64 HeartBeat = 3;
  inline bool has_heartbeat() const;
  inline void clear_heartbeat();
  static const int kHeartBeatFieldNumber = 3;
  inline ::google::protobuf::int64 heartbeat() const;
  inline void set_heartbeat(::google::protobuf::int64 value);

  // optional bool unfreeze = 4;
  inline bool has_unfreeze() const;
  inline void clear_unfreeze();
  static const int kUnfreezeFieldNumber = 4;
  inline bool unfreeze() const;
  inline void set_unfreeze(bool value);

  inline MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:wire.Message)
 private:
  inline void set_has_event();
  inline void set_has_setup();
  inline void set_has_heartbeat();
  inline void set_has_unfreeze();

  inline bool has_MessageType();
  void clear_MessageType();
  inline void clear_has_MessageType();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageTypeUnion {
    ::wire::Event* event_;
    ::wire::ContestSetup* setup_;
    ::google::protobuf::int64 heartbeat_;
    bool unfreeze_;
  } MessageType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_scoreboard_2eproto();
  friend void protobuf_AssignDesc_scoreboard_2eproto();
  friend void protobuf_ShutdownFile_scoreboard_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Team = 6;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 6;
  inline ::google::protobuf::int64 team() const;
  inline void set_team(::google::protobuf::int64 value);

  // required int64 Problem = 1;
  inline bool has_problem() const;
  inline void clear_problem();
  static const int kProblemFieldNumber = 1;
  inline ::google::protobuf::int64 problem() const;
  inline void set_problem(::google::protobuf::int64 value);

  // required int64 SubmitCount = 2;
  inline bool has_submitcount() const;
  inline void clear_submitcount();
  static const int kSubmitCountFieldNumber = 2;
  inline ::google::protobuf::int64 submitcount() const;
  inline void set_submitcount(::google::protobuf::int64 value);

  // required int64 Penalty = 3;
  inline bool has_penalty() const;
  inline void clear_penalty();
  static const int kPenaltyFieldNumber = 3;
  inline ::google::protobuf::int64 penalty() const;
  inline void set_penalty(::google::protobuf::int64 value);

  // optional int64 ContestTime = 7;
  inline bool has_contesttime() const;
  inline void clear_contesttime();
  static const int kContestTimeFieldNumber = 7;
  inline ::google::protobuf::int64 contesttime() const;
  inline void set_contesttime(::google::protobuf::int64 value);

  // required .wire.SState State = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::wire::SState state() const;
  inline void set_state(::wire::SState value);

  // optional .wire.Event Unfrozen = 5;
  inline bool has_unfrozen() const;
  inline void clear_unfrozen();
  static const int kUnfrozenFieldNumber = 5;
  inline const ::wire::Event& unfrozen() const;
  inline ::wire::Event* mutable_unfrozen();
  inline ::wire::Event* release_unfrozen();
  inline void set_allocated_unfrozen(::wire::Event* unfrozen);

  // @@protoc_insertion_point(class_scope:wire.Event)
 private:
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_problem();
  inline void clear_has_problem();
  inline void set_has_submitcount();
  inline void clear_has_submitcount();
  inline void set_has_penalty();
  inline void clear_has_penalty();
  inline void set_has_contesttime();
  inline void clear_has_contesttime();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_unfrozen();
  inline void clear_has_unfrozen();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 team_;
  ::google::protobuf::int64 problem_;
  ::google::protobuf::int64 submitcount_;
  ::google::protobuf::int64 penalty_;
  ::google::protobuf::int64 contesttime_;
  ::wire::Event* unfrozen_;
  int state_;
  friend void  protobuf_AddDesc_scoreboard_2eproto();
  friend void protobuf_AssignDesc_scoreboard_2eproto();
  friend void protobuf_ShutdownFile_scoreboard_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class ContestSetup : public ::google::protobuf::Message {
 public:
  ContestSetup();
  virtual ~ContestSetup();

  ContestSetup(const ContestSetup& from);

  inline ContestSetup& operator=(const ContestSetup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContestSetup& default_instance();

  void Swap(ContestSetup* other);

  // implements Message ----------------------------------------------

  ContestSetup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContestSetup& from);
  void MergeFrom(const ContestSetup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .wire.Team Teams = 2;
  inline int teams_size() const;
  inline void clear_teams();
  static const int kTeamsFieldNumber = 2;
  inline const ::wire::Team& teams(int index) const;
  inline ::wire::Team* mutable_teams(int index);
  inline ::wire::Team* add_teams();
  inline const ::google::protobuf::RepeatedPtrField< ::wire::Team >&
      teams() const;
  inline ::google::protobuf::RepeatedPtrField< ::wire::Team >*
      mutable_teams();

  // repeated .wire.Problem Problems = 3;
  inline int problems_size() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 3;
  inline const ::wire::Problem& problems(int index) const;
  inline ::wire::Problem* mutable_problems(int index);
  inline ::wire::Problem* add_problems();
  inline const ::google::protobuf::RepeatedPtrField< ::wire::Problem >&
      problems() const;
  inline ::google::protobuf::RepeatedPtrField< ::wire::Problem >*
      mutable_problems();

  // required int64 Start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::int64 start() const;
  inline void set_start(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:wire.ContestSetup)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start();
  inline void clear_has_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::wire::Team > teams_;
  ::google::protobuf::RepeatedPtrField< ::wire::Problem > problems_;
  ::google::protobuf::int64 start_;
  friend void  protobuf_AddDesc_scoreboard_2eproto();
  friend void protobuf_AssignDesc_scoreboard_2eproto();
  friend void protobuf_ShutdownFile_scoreboard_2eproto();

  void InitAsDefaultInstance();
  static ContestSetup* default_instance_;
};
// -------------------------------------------------------------------

class Problem : public ::google::protobuf::Message {
 public:
  Problem();
  virtual ~Problem();

  Problem(const Problem& from);

  inline Problem& operator=(const Problem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Problem& default_instance();

  void Swap(Problem* other);

  // implements Message ----------------------------------------------

  Problem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Problem& from);
  void MergeFrom(const Problem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required string Label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional string Color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // @@protoc_insertion_point(class_scope:wire.Problem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 id_;
  ::std::string* label_;
  ::std::string* color_;
  friend void  protobuf_AddDesc_scoreboard_2eproto();
  friend void protobuf_AssignDesc_scoreboard_2eproto();
  friend void protobuf_ShutdownFile_scoreboard_2eproto();

  void InitAsDefaultInstance();
  static Problem* default_instance_;
};
// -------------------------------------------------------------------

class Team : public ::google::protobuf::Message {
 public:
  Team();
  virtual ~Team();

  Team(const Team& from);

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Team& default_instance();

  void Swap(Team* other);

  // implements Message ----------------------------------------------

  Team* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Affiliation = 3;
  inline bool has_affiliation() const;
  inline void clear_affiliation();
  static const int kAffiliationFieldNumber = 3;
  inline const ::std::string& affiliation() const;
  inline void set_affiliation(const ::std::string& value);
  inline void set_affiliation(const char* value);
  inline void set_affiliation(const char* value, size_t size);
  inline ::std::string* mutable_affiliation();
  inline ::std::string* release_affiliation();
  inline void set_allocated_affiliation(::std::string* affiliation);

  // @@protoc_insertion_point(class_scope:wire.Team)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_affiliation();
  inline void clear_has_affiliation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 id_;
  ::std::string* name_;
  ::std::string* affiliation_;
  friend void  protobuf_AddDesc_scoreboard_2eproto();
  friend void protobuf_AssignDesc_scoreboard_2eproto();
  friend void protobuf_ShutdownFile_scoreboard_2eproto();

  void InitAsDefaultInstance();
  static Team* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// optional .wire.Event event = 1;
inline bool Message::has_event() const {
  return MessageType_case() == kEvent;
}
inline void Message::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void Message::clear_event() {
  if (has_event()) {
    delete MessageType_.event_;
    clear_has_MessageType();
  }
}
inline const ::wire::Event& Message::event() const {
  return has_event() ? *MessageType_.event_
                      : ::wire::Event::default_instance();
}
inline ::wire::Event* Message::mutable_event() {
  if (!has_event()) {
    clear_MessageType();
    set_has_event();
    MessageType_.event_ = new ::wire::Event;
  }
  return MessageType_.event_;
}
inline ::wire::Event* Message::release_event() {
  if (has_event()) {
    clear_has_MessageType();
    ::wire::Event* temp = MessageType_.event_;
    MessageType_.event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_event(::wire::Event* event) {
  clear_MessageType();
  if (event) {
    set_has_event();
    MessageType_.event_ = event;
  }
}

// optional .wire.ContestSetup setup = 2;
inline bool Message::has_setup() const {
  return MessageType_case() == kSetup;
}
inline void Message::set_has_setup() {
  _oneof_case_[0] = kSetup;
}
inline void Message::clear_setup() {
  if (has_setup()) {
    delete MessageType_.setup_;
    clear_has_MessageType();
  }
}
inline const ::wire::ContestSetup& Message::setup() const {
  return has_setup() ? *MessageType_.setup_
                      : ::wire::ContestSetup::default_instance();
}
inline ::wire::ContestSetup* Message::mutable_setup() {
  if (!has_setup()) {
    clear_MessageType();
    set_has_setup();
    MessageType_.setup_ = new ::wire::ContestSetup;
  }
  return MessageType_.setup_;
}
inline ::wire::ContestSetup* Message::release_setup() {
  if (has_setup()) {
    clear_has_MessageType();
    ::wire::ContestSetup* temp = MessageType_.setup_;
    MessageType_.setup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_setup(::wire::ContestSetup* setup) {
  clear_MessageType();
  if (setup) {
    set_has_setup();
    MessageType_.setup_ = setup;
  }
}

// optional int64 HeartBeat = 3;
inline bool Message::has_heartbeat() const {
  return MessageType_case() == kHeartBeat;
}
inline void Message::set_has_heartbeat() {
  _oneof_case_[0] = kHeartBeat;
}
inline void Message::clear_heartbeat() {
  if (has_heartbeat()) {
    MessageType_.heartbeat_ = GOOGLE_LONGLONG(0);
    clear_has_MessageType();
  }
}
inline ::google::protobuf::int64 Message::heartbeat() const {
  if (has_heartbeat()) {
    return MessageType_.heartbeat_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Message::set_heartbeat(::google::protobuf::int64 value) {
  if (!has_heartbeat()) {
    clear_MessageType();
    set_has_heartbeat();
  }
  MessageType_.heartbeat_ = value;
}

// optional bool unfreeze = 4;
inline bool Message::has_unfreeze() const {
  return MessageType_case() == kUnfreeze;
}
inline void Message::set_has_unfreeze() {
  _oneof_case_[0] = kUnfreeze;
}
inline void Message::clear_unfreeze() {
  if (has_unfreeze()) {
    MessageType_.unfreeze_ = false;
    clear_has_MessageType();
  }
}
inline bool Message::unfreeze() const {
  if (has_unfreeze()) {
    return MessageType_.unfreeze_;
  }
  return false;
}
inline void Message::set_unfreeze(bool value) {
  if (!has_unfreeze()) {
    clear_MessageType();
    set_has_unfreeze();
  }
  MessageType_.unfreeze_ = value;
}

inline bool Message::has_MessageType() {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void Message::clear_has_MessageType() {
  _oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline Message::MessageTypeCase Message::MessageType_case() const {
  return Message::MessageTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// required int64 Team = 6;
inline bool Event::has_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_team() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_team() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_team() {
  team_ = GOOGLE_LONGLONG(0);
  clear_has_team();
}
inline ::google::protobuf::int64 Event::team() const {
  // @@protoc_insertion_point(field_get:wire.Event.Team)
  return team_;
}
inline void Event::set_team(::google::protobuf::int64 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:wire.Event.Team)
}

// required int64 Problem = 1;
inline bool Event::has_problem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_problem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_problem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_problem() {
  problem_ = GOOGLE_LONGLONG(0);
  clear_has_problem();
}
inline ::google::protobuf::int64 Event::problem() const {
  // @@protoc_insertion_point(field_get:wire.Event.Problem)
  return problem_;
}
inline void Event::set_problem(::google::protobuf::int64 value) {
  set_has_problem();
  problem_ = value;
  // @@protoc_insertion_point(field_set:wire.Event.Problem)
}

// required int64 SubmitCount = 2;
inline bool Event::has_submitcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_submitcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_submitcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_submitcount() {
  submitcount_ = GOOGLE_LONGLONG(0);
  clear_has_submitcount();
}
inline ::google::protobuf::int64 Event::submitcount() const {
  // @@protoc_insertion_point(field_get:wire.Event.SubmitCount)
  return submitcount_;
}
inline void Event::set_submitcount(::google::protobuf::int64 value) {
  set_has_submitcount();
  submitcount_ = value;
  // @@protoc_insertion_point(field_set:wire.Event.SubmitCount)
}

// required int64 Penalty = 3;
inline bool Event::has_penalty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_penalty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_penalty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_penalty() {
  penalty_ = GOOGLE_LONGLONG(0);
  clear_has_penalty();
}
inline ::google::protobuf::int64 Event::penalty() const {
  // @@protoc_insertion_point(field_get:wire.Event.Penalty)
  return penalty_;
}
inline void Event::set_penalty(::google::protobuf::int64 value) {
  set_has_penalty();
  penalty_ = value;
  // @@protoc_insertion_point(field_set:wire.Event.Penalty)
}

// optional int64 ContestTime = 7;
inline bool Event::has_contesttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_contesttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_contesttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_contesttime() {
  contesttime_ = GOOGLE_LONGLONG(0);
  clear_has_contesttime();
}
inline ::google::protobuf::int64 Event::contesttime() const {
  // @@protoc_insertion_point(field_get:wire.Event.ContestTime)
  return contesttime_;
}
inline void Event::set_contesttime(::google::protobuf::int64 value) {
  set_has_contesttime();
  contesttime_ = value;
  // @@protoc_insertion_point(field_set:wire.Event.ContestTime)
}

// required .wire.SState State = 4;
inline bool Event::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::wire::SState Event::state() const {
  // @@protoc_insertion_point(field_get:wire.Event.State)
  return static_cast< ::wire::SState >(state_);
}
inline void Event::set_state(::wire::SState value) {
  assert(::wire::SState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:wire.Event.State)
}

// optional .wire.Event Unfrozen = 5;
inline bool Event::has_unfrozen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_unfrozen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_unfrozen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_unfrozen() {
  if (unfrozen_ != NULL) unfrozen_->::wire::Event::Clear();
  clear_has_unfrozen();
}
inline const ::wire::Event& Event::unfrozen() const {
  // @@protoc_insertion_point(field_get:wire.Event.Unfrozen)
  return unfrozen_ != NULL ? *unfrozen_ : *default_instance_->unfrozen_;
}
inline ::wire::Event* Event::mutable_unfrozen() {
  set_has_unfrozen();
  if (unfrozen_ == NULL) unfrozen_ = new ::wire::Event;
  // @@protoc_insertion_point(field_mutable:wire.Event.Unfrozen)
  return unfrozen_;
}
inline ::wire::Event* Event::release_unfrozen() {
  clear_has_unfrozen();
  ::wire::Event* temp = unfrozen_;
  unfrozen_ = NULL;
  return temp;
}
inline void Event::set_allocated_unfrozen(::wire::Event* unfrozen) {
  delete unfrozen_;
  unfrozen_ = unfrozen;
  if (unfrozen) {
    set_has_unfrozen();
  } else {
    clear_has_unfrozen();
  }
  // @@protoc_insertion_point(field_set_allocated:wire.Event.Unfrozen)
}

// -------------------------------------------------------------------

// ContestSetup

// required string Name = 1;
inline bool ContestSetup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContestSetup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContestSetup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContestSetup::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ContestSetup::name() const {
  // @@protoc_insertion_point(field_get:wire.ContestSetup.Name)
  return *name_;
}
inline void ContestSetup::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:wire.ContestSetup.Name)
}
inline void ContestSetup::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:wire.ContestSetup.Name)
}
inline void ContestSetup::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wire.ContestSetup.Name)
}
inline ::std::string* ContestSetup::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wire.ContestSetup.Name)
  return name_;
}
inline ::std::string* ContestSetup::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContestSetup::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wire.ContestSetup.Name)
}

// repeated .wire.Team Teams = 2;
inline int ContestSetup::teams_size() const {
  return teams_.size();
}
inline void ContestSetup::clear_teams() {
  teams_.Clear();
}
inline const ::wire::Team& ContestSetup::teams(int index) const {
  // @@protoc_insertion_point(field_get:wire.ContestSetup.Teams)
  return teams_.Get(index);
}
inline ::wire::Team* ContestSetup::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:wire.ContestSetup.Teams)
  return teams_.Mutable(index);
}
inline ::wire::Team* ContestSetup::add_teams() {
  // @@protoc_insertion_point(field_add:wire.ContestSetup.Teams)
  return teams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wire::Team >&
ContestSetup::teams() const {
  // @@protoc_insertion_point(field_list:wire.ContestSetup.Teams)
  return teams_;
}
inline ::google::protobuf::RepeatedPtrField< ::wire::Team >*
ContestSetup::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:wire.ContestSetup.Teams)
  return &teams_;
}

// repeated .wire.Problem Problems = 3;
inline int ContestSetup::problems_size() const {
  return problems_.size();
}
inline void ContestSetup::clear_problems() {
  problems_.Clear();
}
inline const ::wire::Problem& ContestSetup::problems(int index) const {
  // @@protoc_insertion_point(field_get:wire.ContestSetup.Problems)
  return problems_.Get(index);
}
inline ::wire::Problem* ContestSetup::mutable_problems(int index) {
  // @@protoc_insertion_point(field_mutable:wire.ContestSetup.Problems)
  return problems_.Mutable(index);
}
inline ::wire::Problem* ContestSetup::add_problems() {
  // @@protoc_insertion_point(field_add:wire.ContestSetup.Problems)
  return problems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wire::Problem >&
ContestSetup::problems() const {
  // @@protoc_insertion_point(field_list:wire.ContestSetup.Problems)
  return problems_;
}
inline ::google::protobuf::RepeatedPtrField< ::wire::Problem >*
ContestSetup::mutable_problems() {
  // @@protoc_insertion_point(field_mutable_list:wire.ContestSetup.Problems)
  return &problems_;
}

// required int64 Start = 4;
inline bool ContestSetup::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContestSetup::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContestSetup::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContestSetup::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 ContestSetup::start() const {
  // @@protoc_insertion_point(field_get:wire.ContestSetup.Start)
  return start_;
}
inline void ContestSetup::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:wire.ContestSetup.Start)
}

// -------------------------------------------------------------------

// Problem

// required int64 Id = 1;
inline bool Problem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Problem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Problem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Problem::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 Problem::id() const {
  // @@protoc_insertion_point(field_get:wire.Problem.Id)
  return id_;
}
inline void Problem::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:wire.Problem.Id)
}

// required string Label = 2;
inline bool Problem::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Problem::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Problem::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Problem::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Problem::label() const {
  // @@protoc_insertion_point(field_get:wire.Problem.Label)
  return *label_;
}
inline void Problem::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:wire.Problem.Label)
}
inline void Problem::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:wire.Problem.Label)
}
inline void Problem::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wire.Problem.Label)
}
inline ::std::string* Problem::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wire.Problem.Label)
  return label_;
}
inline ::std::string* Problem::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Problem::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wire.Problem.Label)
}

// optional string Color = 3;
inline bool Problem::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Problem::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Problem::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Problem::clear_color() {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& Problem::color() const {
  // @@protoc_insertion_point(field_get:wire.Problem.Color)
  return *color_;
}
inline void Problem::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set:wire.Problem.Color)
}
inline void Problem::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set_char:wire.Problem.Color)
}
inline void Problem::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wire.Problem.Color)
}
inline ::std::string* Problem::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wire.Problem.Color)
  return color_;
}
inline ::std::string* Problem::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Problem::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wire.Problem.Color)
}

// -------------------------------------------------------------------

// Team

// required int64 Id = 1;
inline bool Team::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Team::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Team::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Team::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 Team::id() const {
  // @@protoc_insertion_point(field_get:wire.Team.Id)
  return id_;
}
inline void Team::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:wire.Team.Id)
}

// required string Name = 2;
inline bool Team::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Team::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Team::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Team::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Team::name() const {
  // @@protoc_insertion_point(field_get:wire.Team.Name)
  return *name_;
}
inline void Team::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:wire.Team.Name)
}
inline void Team::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:wire.Team.Name)
}
inline void Team::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wire.Team.Name)
}
inline ::std::string* Team::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wire.Team.Name)
  return name_;
}
inline ::std::string* Team::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Team::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wire.Team.Name)
}

// optional string Affiliation = 3;
inline bool Team::has_affiliation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Team::set_has_affiliation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Team::clear_has_affiliation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Team::clear_affiliation() {
  if (affiliation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    affiliation_->clear();
  }
  clear_has_affiliation();
}
inline const ::std::string& Team::affiliation() const {
  // @@protoc_insertion_point(field_get:wire.Team.Affiliation)
  return *affiliation_;
}
inline void Team::set_affiliation(const ::std::string& value) {
  set_has_affiliation();
  if (affiliation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    affiliation_ = new ::std::string;
  }
  affiliation_->assign(value);
  // @@protoc_insertion_point(field_set:wire.Team.Affiliation)
}
inline void Team::set_affiliation(const char* value) {
  set_has_affiliation();
  if (affiliation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    affiliation_ = new ::std::string;
  }
  affiliation_->assign(value);
  // @@protoc_insertion_point(field_set_char:wire.Team.Affiliation)
}
inline void Team::set_affiliation(const char* value, size_t size) {
  set_has_affiliation();
  if (affiliation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    affiliation_ = new ::std::string;
  }
  affiliation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:wire.Team.Affiliation)
}
inline ::std::string* Team::mutable_affiliation() {
  set_has_affiliation();
  if (affiliation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    affiliation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:wire.Team.Affiliation)
  return affiliation_;
}
inline ::std::string* Team::release_affiliation() {
  clear_has_affiliation();
  if (affiliation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = affiliation_;
    affiliation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Team::set_allocated_affiliation(::std::string* affiliation) {
  if (affiliation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete affiliation_;
  }
  if (affiliation) {
    set_has_affiliation();
    affiliation_ = affiliation;
  } else {
    clear_has_affiliation();
    affiliation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:wire.Team.Affiliation)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wire

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::wire::SState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wire::SState>() {
  return ::wire::SState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_scoreboard_2eproto__INCLUDED
